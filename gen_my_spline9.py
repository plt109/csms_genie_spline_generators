# Script name: gen_my_spline9.py
# Purpose: Takes in native GENIE cross-section splines and :
# 1. Interpolate CSMS xsec at GENIE energy knot points and stick them into
# xml files in the pure CSMS region, ramping them up linearly in the transition
# region
# 2. Null out the rest of the channels in the pure CSMS region, ramping them
# down linearly in the transition region
#
# Pure native GENIE region: [0.01, 70.] GeV
# Transition region: (70., 200.) GeV
# Pure CSMS region: [200., 10000.) GeV
#
# Important variables:
# genieFile: Native GENIE splines that forms the base. 
# outFileName: Filename of output cross section snippet file
# fSurviveList*: List of subchannels that are not nulled out in transition and pure CSMS region
# fNullList*: List of subchannels to be nulled out in transition and pure CSMS region
# Probably not a very good idea to change the things marked by (*)
#
# Copied from
# /Users/peaelle42/Documents/CSMS/codes/mass_production/baseline_codes/gen_my_spline9.py
# Pueh Leng Tan, 14 Jan 2019

import matplotlib.pyplot as plt
import scipy.interpolate as itp
import numpy as np
import sys, pdb
import xml.etree.cElementTree as ET

from readXSecErrFunc2 import *

# Raw CSMS cross-sections from 1106.3723 start from E=50 GeV as paper suggests that
# there are contributions to neutrino cross-sections on order of 10% from
# Q^2<1GeV^2 for below s~100GeV^2
xsecPath = 'csms_xsec_base/'
xsecFileBag = ['nu_iso_cc.dat', 'nu_iso_nc.dat', 'nubar_iso_cc.dat', 'nubar_iso_nc.dat',
        'nu_p_cc.dat', 'nu_p_nc.dat', 'nubar_p_cc.dat', 'nubar_p_nc.dat']

# Read in csms xsec and generate interp func
xsecInterpFuncBag = []
for iFile in range(0,len(xsecFileBag)):
    # energy is linear
    [csmsXsecE_GeV, csmsXsec_pb, dmp, dmp] = readXSecErrFunc2(xsecPath+xsecFileBag[iFile])
    csmsXsec_cm2 = csmsXsec_pb*1e-36
    tmpFunc = itp.interp1d(csmsXsecE_GeV, csmsXsec_cm2, kind='linear')
    xsecInterpFuncBag.append(tmpFunc)

# cross-section purely CSMS from 200 GeV
csmsStartE_GeV = 200
# start to linearly ramp down native GENIE cross-section while ramping up
# CSMS cross-section at 70 GeV
transStartE_GeV = 70

# Native GENIE splines that forms the base
# 12,-12,14,-14,16,-16 on H1, O16 up to 10 TeV, default event generator list
# Generated in GENIE 2.8.6 using
# gmkspl -p 12,-12,14,-14,16,-16 -t 1000080160,1000010010 -e 10000 -o 'full_package_10TeV_default_500knots.xml'
genieFile = 'native_genie/full_package_10TeV_default_500knots.xml'
fSurviveList = 'native_genie/survive_list.txt'
fNullList = 'native_genie/null_list.txt'
outFileName = 'full_package_snippet_v9c.xml'

# Read in survival and null list
surviveName = tuple(open(fSurviveList, 'r').read().split('\n'))
surviveName = filter(str.strip, surviveName) # Getting rid of awkward empty last element
nullName = tuple(open(fNullList, 'r').read().split('\n'))
nullName = filter(str.strip, nullName) # Getting rid of awkward empty last element

# Open XML file for writing
xmlName = open(outFileName, 'w')
xmlName.write('<?xml version="1.0" encoding="ISO-8859-1"?>\n\
<!-- generated by gen_my_spline.py -->\n\
<genie_xsec_spline_list version="2.00" uselog="1">\n\n')

# Reading native GENIE splines
genieTree = ET.parse(genieFile)
genieRoot = genieTree.getroot()

tmp0 = np.shape(genieRoot)
nSpl = tmp0[0] # no. subchannels
nKts = tmp0[1] # no. knots

# Getting names of splines in native GENIE splines
for spl in genieRoot:
    splName = spl.get('name')

    # Fishing only for DIS channels
    fishDIS = splName.find('DIS') 
    if fishDIS<0:
        continue

    fishNC = splName.find('NC')
    fish0 = splName.find('nu:')
    fish1 = splName.find(';tgt:')
    fish2 = splName.find(';N:')
    nuType = int(splName[fish0+3:fish1])
    tgtType = int(splName[fish1+5:fish2])

    if tgtType==1000080160:
        noP = 8
        noN = 8
    elif tgtType==1000010010:
        noP = 1
        noN = 0

    if fishNC<0: # cannot find means it's CC
        ncHalver = 1.
        if nuType<0:
            # CC, anti-neutrinos
            if tgtType==1000010010:
                # nubar CC H1
                xsecInterpFunc = xsecInterpFuncBag[6]
            else:
                # nubar CC O16
                xsecInterpFunc = xsecInterpFuncBag[2]
            '''
            print('Should be CC antinu')
            print('%s' % splName)
            print('%s\n' % xsecFileBag[2])
            '''
        else:
            # CC, neutrinos 
            if tgtType==1000010010: # Only correcting for H1 cause not isoscalar
                # nu CC H1
                xsecInterpFunc = xsecInterpFuncBag[4]
            else:
                # nu CC O16
                xsecInterpFunc = xsecInterpFuncBag[0]
            '''
            print('Should be CC nu')
            print('%s' % splName)
            print('%s\n' % xsecFileBag[0])
            '''
    else: # means it's NC
        ncHalver = 0.5
        if nuType<0:
            # NC, anti-neutrinos
            if tgtType==1000010010:
                # nubar NC H1
                xsecInterpFunc = xsecInterpFuncBag[7]
            else:
                # nubar NC O16
                xsecInterpFunc = xsecInterpFuncBag[3]
            '''
            print('Should be NC antinu')
            print('%s' % splName)
            print('%s\n' % xsecFileBag[3])
            '''
        else:
            # NC, neutrinos
            if tgtType==1000010010:
                # nu NC H1
                xsecInterpFunc = xsecInterpFuncBag[5]
            else:
                # nu NC O16
                xsecInterpFunc = xsecInterpFuncBag[1]

                '''
            print('Should be NC nu')
            print('%s' % splName)
            print('%s\n' % xsecFileBag[1])
            '''

    # Fishing out E and Xsec
    genieE = [] 
    genieXsec = []
    for knt in spl:
        genieE.append(float(knt[0].text))
        genieXsec.append(float(knt[1].text))
    genieE = np.asarray(genieE)
    genieXsec = np.asarray(genieXsec)

    # Find energy knot points in range for transition and interpolation from csms
    tmp = np.where(np.logical_and(genieE>=csmsStartE_GeV, genieE<np.max(csmsXsecE_GeV)))
    tmp = np.squeeze(tmp)

    # Find energy knot points for transition region
    tmpTrans = np.where(genieE>transStartE_GeV)
    tmpTrans = np.squeeze(tmpTrans)
    newStartPt = np.min(tmpTrans)
    indTrans = range(newStartPt, tmp[0])
    nTransPt = len(indTrans)
    if nTransPt<1:
        print('FATAL: No. transition pts = %i' % nTransPt)

    xmlXsecESel_GeV = genieE[tmp] # E value of full csms region
    xmlXsecESelTrans_GeV = genieE[indTrans] # E value of trans csms region
    finXmlSnippetE = np.concatenate((xmlXsecESelTrans_GeV, xmlXsecESel_GeV))

    # Creating ramps for transition region
    rampUp = np.linspace(0,1,nTransPt)
    rampDown = 1-rampUp

    # Deciding to null or not
    if splName in surviveName:
        print('Survived:%s' % splName)

        # Determining nucleon type, p or n
        tmp1 = splName.find('N:')
        nucType = int(splName[tmp1+2:tmp1+6])
        if nucType==2112: # neutron
            multiplicity = noN*ncHalver
        elif nucType==2212: # proton
            multiplicity = noP*ncHalver
        else:
            print('FATAL: Weird nucleon target in %s\n' % splName)

        # Actual interpolation
        xsecInterpperE_cm2perGeV = xsecInterpFunc(xmlXsecESel_GeV)
        xsecInterpperETrans_cm2perGeV = xsecInterpFunc(xmlXsecESelTrans_GeV)

        # Units conversion, si(csms paper) -> nu(xml)
        xsecInterpperE_perGeV3 = xsecInterpperE_cm2perGeV*(5.07e13)*(5.07e13)
        xsecInterpperETrans_perGeV3 = xsecInterpperETrans_cm2perGeV*(5.07e13)*(5.07e13)

        nyan = xsecInterpperETrans_perGeV3*multiplicity*rampUp + genieXsec[indTrans]*rampDown
        finXmlSnippet = np.concatenate((nyan, xsecInterpperE_perGeV3*multiplicity))

    elif splName in nullName:
        print('Nulled:%s' % splName)

        nyan = genieXsec[indTrans]*rampDown
        finXmlSnippet = np.concatenate((nyan, np.zeros(np.shape(xmlXsecESel_GeV))))

    else:
        continue
    '''    
    # Plots for sanity checks
    f1 = plt.figure()
    ax1 = f1.add_subplot(111)
    plt.plot(genieE, genieXsec)
    plt.plot(finXmlSnippetE, finXmlSnippet, 'r')
    plt.title(splName)
    ax1.set_xlabel(r'$E_\nu [GeV]$')
    ax1.set_ylabel(r'$\sigma_{CCDIS} [GeV^{-2}]$')
    ax1.grid(True, which='both')
    f1.show()
    '''

    # Writing spline snippet 
    xmlName.write('<spline name="%s" nknots="%i">\n' % (splName, nKts))
    for ind in range(0, np.size(finXmlSnippetE)):
        xmlName.write('\t<knot> <E>%.5f</E> <xsec>%.9e </xsec> </knot>\n' %
                (finXmlSnippetE[ind],finXmlSnippet[ind]))
    xmlName.write('</spline>\n')
xmlName.write('</genie_xsec_spline_list>\n')
